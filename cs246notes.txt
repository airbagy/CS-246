CS246

USEFUL: w3m https://marmoset.student.cs.uwaterloo.ca
                 ssh y27duan@linux.student.cs.uwaterloo.ca
                 source /u/cs246/setup
                 marmoset_submit cs246 ..

Lecture 1:

Prof: Numer

Terminal Shell 2 weeks

C++ 10 weeks

A “shell” is an interface to the OS(operating system).

2 kinds of shells: Graphic and Command Line

Graphic : intuitive and easy yet limited in functionality!!

Command Line : type command on a “command prompt”,
                             not limited by functionality,
                             yet steep learning curve.

Linux Shell: csh ksh turbo c shell(tcsh) Bowine Again Shell(bash)

$ echo $0 // this test if you are using bash.

Linux File System: 
- contains files
- some files can contain other files(directory)
- root dir: /
- PATH: the location of a file
- “/” has two meanings: root or separation
- files can be hidden (configuration)

Command:
- $> to indicate command prompt
- echo $0: what kind of shell
- ls : listing
- ls -a : (command argument) list all files
- pwd : present working dir
- cd … : change dir
- cd /dir1/dir2/dir3 : (use a path) this changes the dir to the end
- cd .. : to higher level
- cat dir1/dir2/dir3 : prints content of files
- cat : repeat whatever you say
- ssh : secure shell 
- scp : secure copy (scp y27duan@…: ~/cs246/a0.pdf .)
- echo : prints arguments to stdout
- exit : exit the current shell
- alias : substitution string for command name (alias l=‘ls’) remember to always use quotes!!
- type : alias-reverse
- type -p : only show the command file-name

- cp : copy files; with -r option, copy directories(its better to use -i)
- mv : move files or directories to another location(use -i)
- rm : remove(delete) files, use -r to remove directories !!CAREFUL!! No recovering
- time : execute a command and print a time summary
- sh/bash/csh/tcsh : start subshell
- more/less : print files separately
- lp/lpstat/lprm : add query and re35move files from the printer queues
- cmp/diff : compare 2 files and print differences, returns 0 if equal
- head [-args] : prints out the first ‘arg’ lines (head -20 test.txt)
- .profile !!!! Very useful
- command arg1 arg2 > out.txt
- (control c : stop)
- (control -D means END OF FILE)
- (absolute path: the one that starts with the root dir.)
- (relative path: the one that stats with the current dir.)

Output Redirection: redirect the output of a program/command of a file.

git.uwaterloo.ca

to get g++ at least version 5:
Checkup: HOMEBREW 


Lecture 2:

Output Redirection: redirects output to a file

$ command [args] > filename

Input Redirection: direct contents of a file into a program.

$ command [args] < filename

E.G. 

$ cat sample.txt
=> sample.txt is an argument to cat
=> cat opens the file and reads it

$ cat < sample.txt
=> there is no argument!!
=> the shell opens file sample.txt and sends the content to cat

E.G.

$ wc test.txt
=> 1 2 3 test.txt

$ wc < test.txt
=> 1 2 3
# Here the command wc does not know about which file it is reading

Input/Output Streams:

stdin -> process -> stdout

stdin: default: keyboard
           use < to change to file

stdout: default: screen
              use > to change to file

stderr: default: screen
             use 2> to change to file

E.G.

$ cat < in.txt > out.txt 2> err.txt
# this reads from in.txt output to out.txt and produce error to err.txt if there is an error.

!! use >> to append not overwrite !!

E.G.

command > out.txt 2> &1
# this redirect both stdout and stderr to out.txt

WILDCARD MATCHING:

E.G.

$ cat *.txt
=> cat abc.txt def.txt
#        globbing parttern
# this do the command to all the files end with .txt
# The shell choose all the file in pwd that satisfy this pattern

PIPES:

This directly connect the output of a process to another input process!!!

| This is the pipe symbol!!!!

head -20 sample.txt | wc -w

E.G.

suppose files words*.txt contain list of words, one per line. Print a duplicate free list of all words in word*.txt

cat words*.txt | sort | uniq

USE THE OUTPUT AS AN ARGUMENT:

E.G.

$ echo “Today is $(date) and I am $(whoami).”
# $(…) is called embedding command

!!!!!!!!

$ echo “$(date)”
=> prints out the date

$ echo ‘$(date)’
=> prints out $(date)

!!!!!!!!!

‘…’ prevents embedding commands from executing!

Pattern Matching:

egrep : extended global regular expression print
!!! This is case sensitive !!!

$ egrep [regular expression pattern] [files you want to search]
=> this prints every line in the line/lines that matches the pattern

E.G.

$ egrep thou sample.txt
=> two lines that contains the pattern “thou”
=> thousand…
      thought…

we can use the logic symbol ‘or’(‘|’) in our expression, but we need to use a string!!!

So always use double quotes in egrep!!

E.G.

$ egrep “cs246|CS246” index.shtml | wc -l
$ egrep (cs|CS)246 … # this is the same 
$ egrep (C|S)(c|s)246 … # this is NOT the same

SYNTAX:
# [abc] : is short hand for a|b|c
# [^abc] : one character not in the set
# ? : 0 or 1 of the previous subexpression “cs ?246” 
          — this means “cs246” or “cs 246”
# + : 1 or more of the previous subexpression
# * : 0 or more 
# . : match any one character
# .* : match 0 or more of any charactors
# [a-z] : 1 character from a to z
# \ : The character after this will be read as char


- To insist that lines matched must begin with some pattern, use ^.
- To insist that there is no character after the pattern has matched on a line, use $
E.G. 
“^cs.*246”
“cs.*246$”

Fetch lines of even length:

$ egrep “^(..)*$” filename

List all files in the  current directory whose name contains exactly one “a”:

$ ls | egrep “^[^a]*a[^a]*$”

File Permissions:

- ls -l : long listing

$ ls -l
=> -rwxr-xr-x 1 Dennis Staff 102 8 May 00:00 tut
:::::::9 bits dictate file permissions
:::::::::::::::::::::::symbolic links
user, group, size, last modified, filename

 rwx  r-x  r—
 user bits: owner permission
         group bits: permissions for users in the same group
                others bits: all other users

r: read
w: write
x: execute

For directories, x means if one can get into the directory.

- Only the owner can modify permissions
- The command is: chmod
- $ chmod mode file(s)
- !! mode is made of 3 components:
- ownership | operator | permissions
- ownership: u, g, o or a for all
- operator +, -, =
- permissions: r, w, x

E.G.

$ chmod o+r file.txt
$ chmod a=rx *

Shell variables:

$ x=1 
!! no space !!

$ y=“Hello World!”
!! all shell variables are strings !!

$ echo $x
=> 1

$ echo ${x}
=> 1

$ dir=~/cs246
$ echo $dir
=> /User/Dennis/cs246

$ echo “$dir”
=> User/Dennis/cs246

$ echo ‘$dir’
=> $dir

!! when using single quotes, this is seen as a string !!

Global Predefined Variables:

$?

$PATH: This is a collection to paths to directories separated by “:”

!! When executing a command, the terminal search for the command in the $PATH dirs !!

Shell Scripts:

Text file containing a sequence of linux commands/programs execute as a program.

E.G.

File: basic

#!/bin/bash
whoami
pwd
date

File End

!! When using the scripts, it is needed to specify the path to the scripts !!

$ ./basic
=> Dennis
=> /User/Dennis/cs246
=> Tue 9 May…

!! Command Line Arguments to a script are accessible within the script using $1, $2… !!

E.G.

File: AAA

#!/bin/bash
egrep “^$1$” /user/share/dict/words

File End

$ ./AAA hello
=> hello
$ ./AAA dwg
=> 

Good Password
- is the given word a good password?
- Not a good password if in the dictionary.

#!/bin/bash

egrep “^$1$” /usr/share/dict/words > /dev/null

!! Every command/process sets a status code ($?) !!

Linux Convention: 
0 -success 
non-zero -failure

For egrep:
0 -success
1 -failure

How to compare $? with 0 or 1?

Test Program:

[ $? -eq 0 ]
!!This set the current status quote ($?) to 0 if success!!

- ${#} is the number of arguments to the script.
- $0 : the string the user typed before the first argument.(The script name)

exit 1 : exit script because of failure!!
exit 0 (exit) : just exit (exit because of success)

TUT2:

- ls -al : long list and all the files
- ls -h : humanly readable
- uniq : remove consecutive duplicates
- uniq -c : print counts of consecutive duplicates
- sort : sort the lines(ASCII order)
- sort -n : sort numerically
- head/tail : print first/last 10 lines to stdout
- head/tail -5 : print the first/last 5 lines
- sort -k2r : sort by the second key and reverse it
- sort -k1n -k2r : first sort by the first key numerically and the sort by the second key reversed
- 

E.G.

!! echo “ERROR” 1>&2 !!
!! ./printer &> out !! # This will put both output to a file out!!
!! ./printer > /dev/null !! use blackhole

$() can be nested
‘’ cannot be nested
“” only suppress globbing paterns

TUT ENDS

If $8 is used and there is no 8th argument, $8 will be a empty string.

If Statement:

E.G.

if [$? -eq 0]; then
  echo Not a good password
else 
  echo Maybe a good password
fi

Syntax: 
if [condition]; then
  …
elif [condition]; then
  …
else 
   …
fi

Conditions:
- -eq, -ne, -le, -lt
- [-e file.txt]
- -a(and), -o(or), !(not)
- =, !=

While loop:

E.G.

File:

#!/bin/bash

x=1;
while [$x -le $1]; do
  echo $x
  x=$((x+1)) # When assigning, no “$” is needed.
done

For Loop:

for i in a b c d; do echo $i; done

E.G.

Rename all .C files to .cc:

for name in *.C; do
  mv ${name} ${name%C}cc
done

How to rename:
We can use $ mv hello.C hello.cc

file = hello.C
$ mv $file ${file%C}cc # This will change .C to .cc

file = 123Hello
 ${file#123} # This will remove 123

????? */.c ????? subdirectories ???????
!!! For terminal “/n” “/tab” are treated as whitespace !!!!!!!

E.G.

Count the number of occurrences of $1 in the file $2:

count=0
for word in $(cat $2) ; do
  if [$word = “$1”]; then # double quotes prevents error
    count = $count + 1
  fi
done
echo $count

!!! ALWAYS USE DOUBLE QUOTES IN ANY USER INPUT !!!

E.G.

Do check out script: payday

$ cal | awk ‘ {print $6} ’ | egrep [0-9] | tail -1

$ cal June 2017 | awk ‘ {print $6} ’ | egrep [0-9] | tail -1

Module 2:
C++:

Bjaine Stroustrup

C++ : C with classes
C++99 : most stable
C++03 : used to teach
C++11 : starts every 3 years
C++14 : ours version

Most C programs are valid C++ programs

In C:

#include <stdio.h>

int main(void) {
	printf(“Hello World!\n”);
	return 0;
}

In C++:

#include <iostream>
using namespace std;

int main() {
	cout <<“Hello World!”<<endl;
	return 0;
}

DIFFERENCE:
1. In C, we include stdio.h to use printf to output to stdout.
2. Using printf is not allowed in CS246.
3. In C++, we include <iostream>
4. std::cout <<data1<<data2;
5. std::cout <<endl;
6. To compile the source file, use the command g++-5

$ g++-5 -std=c++14 hello.cc
=> # by default, produces file a.out
$ ./a.out
=> runs the program

g++14 hello.cc -0 myprogram

cout:

When we include <iostream> we are importing three stream variables:
- cout (type ostream) : write to stdout;
- cerr (type ostream) : write to stderr;
- cin (type istream) : read from stdin;

C++ also provides: 
- output operator : << ;
- input operator : >> ;

E.G. read 2 int and add them up

#include <iostream>
using namespace std;

int main() {
	int x, y;
	cin >> x >> y;
	cout << x+y << endl;
}



!!! cin skips white spaces :
- it starts at first non-whitespace char until the first whitespace is hit.
- if a read fails (because of non-int) the variable is left unchanged but the program continues.
- if a read fails due to EOF, the program still continues!!
- !! wherever we do a read, it is a good idea to check if it succeeded !!
- if the read fails, then the expression cin.fail() is true;
- if the read fails due to EOF, then cin.fail() and cin.eof() are true!!

E.G.  Read all ints from stdin and echo them to stdout. Stop when a read fails.

int main() {
	int i,
	while(true) {
		cin >> i;
		if (cin.fail()) break;
		cout << i << endl;
	}
}

There is an automatic conversion from can to bool(implicit conversion)!!

!! cin is true whenever the cin.fail() is false!!

We can rewrite the previous code!!

int main() {
	int i;
	while(true) { 		cin>>i;
		if(!cin) break;
		cout <<i<<endl;
	}
}

cin >> i; // This is a single expression. It is binary!!

!! it produces a value !! which is “cin” !!

so when using 

      cin >> x >> y
=> cin >> y
=> cin // which we throw away!!

!! If a read fails, all the following reads fail(unless we do something) !!

We can rewrite the previous code!!

int main() {
	int i;
	while(true) {
		if(!(cin>>i)) break;
		cout <<i<<endl;
	}
}

==>

int main() {
	int i;
	while(cin>>i) {
		 cout << i << endl;
	}
}

E.G. Read all ints and echo to stdout skip non-ints End at EOF.

int main() {
	int i;
	while(true) {
		if(cin >> i) {
			cout << i << endl;
		}
		else {
			if (cin.eof()) break;
			cin.clear();
			cin.ignore;
		}
	}
}

If a dead fails, all future reads fail.
!! The offending char will be read again and again if no con.ignore() is used !! 
- use cin.clear() to acknowledge the failure;
- use cin.ignore() to ignore the “next” character;

C++ actually has a string type

# include <string>

int main(){
	string s;
	cin >> s;
	cout << s << endl;
}

!!
=> Hello world!
=> Hello // cin will read from first non-whitespace char until it reaches another whitespace.

To read an entire line:
getline(cin, s);
This will keep reading until it hits a newline.

In C, we will need to remember format specifiers, while in C++ the declared type is enough for cin.

In C, we can use format specifiers to change how input was read or how output was produced. In C++ the process is different!

In C++, we can do the same or more using IO manipulators.

we must include <iomanip>

int x=95;
cout << x;
cout << hex; // from this on, we print hexidecimal
cout << x;
cout << dec; // from this on, we print decimal

see <iomanip>
- showpoint
- setprecision
- boolalpha
- skipws
- noskipws 

TUT2:

program arg1…argn < input > output

- Bash variables

$ var=42
$ echo var
=> 42

$ echo ${var%2}
=> 4

$ “wc -l”
=> error

- Exit code

exit 0 (in bash shell)

0 : no error
1-255 : some error

- Loops, ifs, test

1)
if [cond1]; then
	…
elif [cond2]; then
	…
else
	…
fi

2)
for var in <words>; do
	…
done

3)
while [cond]; do
	…
done

$ seq 0 10
=> 0 1 2 3 4 5 6 … 10
$ {0..2}
=> 0 1 2

Test: [

$ [ 2 -le 3 ]; echo $?
=> 0

- Bash scripting

use #!/bin/bash
$# number of arguments
$@ all args



!! In bash scripts, all variables are execution scopes !!

!! Test does not guarantee correctness !!

- Testing

Black-box testing

White-box testing (Unit testing)

What should be tested? 
- General case
- Boundary
- Equivalence 
- Corner/ Weird cases


$ bash -x
=> prints out all the commands!!

TUT ENDS

MORE IO/ Short topics

The some “stream abstraction” can apply to other forms of data
-> read/write to files
#include <fstream>
- ifstream : read from a file
- ofstream :write to a file

E.G.

int main() {
	ifstream filesteam{“myfile.txt”};
	sting s;
	while (filestream >> s) {
		cout << s << endl;
	}
}

You can do everything with a ifstream variable that you could do with cin (istream)
!! ofstream variable are similar to cout(ostream) !!

We can treat a string as a source of data

#include <sstream>
- istringstream_ input_ read from a string
- ostringstream_ output_ write to a string

int lo = 2, hi = 5;

io/buildstring.cc
ostringstream os;
os << “Enter a number between ” << hi << “and ” << lo << endl;
string s = os.str();
cout s;

E.G.

insisting on the user to enter a number

int main() {
	int num;
	while(true) {
		cout << “Enter a number” << endl;
		string s;
		cin >> s;
		istringstream ss{s};
		if (ss>num) break;
 	}
}

String:

In C, we used char arrays to  store a string

In C++, there is a string type
- include <string>
- automatically manage size!!

stirng s = “hello”


!!! C string is different from C++ !!!

[在这里添加图片]

Default Arguments

void printfile(string name=“myfile.txt”) {
	string s;
	ifstream filestream{name};
	while (filestream >> s) {
		cout << s << endl;
	}
}

!! name=“myfile.txt” is just a default argument, you can always pass on a perimeter to change the default.

You cannot follow a parameter with a default value with one that does not have a default value.

That is, parameter with a default value must occur last!!!

E.G.

void - test(int num=0, string str); NOT VALID

void test(int num=0, string str=“bla”); VALID

If you are going to leave out an argument it must be the last (or the last n).

test(5, “blabla”); VALID
test(5); VALID
test(); VALID
test(“blabla”); NOT VALID
!!! test(,”blabla”); NOT VALID !!!

If our program implements 
	void test(int num=0, string str=“ ”);
We cannot implement
	void test();
	void test(int);
	void test(int, string);

Function Overloading
It is legal in C++ to create a function with the same name as long as there is a difference i nth number and/or types of parameters

E.G.
int neg(int a) {return -a};

bool neg(bool a) {return !a};

int a=21;
int b=3;
a = a>>b (bit shift)

cin >> x;

How the complier tell the difference:

The type of variables

struct:

C:

struct Node {
	int data;
	struct Node * next;
};

struct Node n ={5, NULL}

C++:

struct Node {
	int data;
	Node * next;
};

Node n{5, nullptr}
# This is uniform initialization!!

TUT:

- C++ style strings

#include <string>
stirng s = “abc”;
// We can do:
s[1];
s + “abc”;
==, !=, >, <;
s.length(), s.clear(), s.substr(), s.find(…), 
s.c-str() : returens a const char * of C++ string

- streams

istream : 
	cin >> x;
	cin.eof();
	cin.fail() : (check eof after fail);
	cin.clear() : set fail bit to false;
	cin.ignore() : read next char and discard it;
	
	subtype: ifstream, istringstream
		ifstream ifs{filename};  (a new syntax in c++ 11)
		

ostream:
	cout << x;
	ostringstream oss;
	oss.str() : give C++ syle string inside OSS.
		
		ofstream ofs{filename}; 
		


- parameters

	int f(int x, int y);
	bool f(int x);

	name + number and type of arguments = signature

TUT ENDS

void inc(int n) {
	n = n + 1;
} 

int x = 5;
inc(x);
cout << x << endl; // prints out 5

!! to increment x, we need to pass by pointer !!

void inc(int *n) { 	*n += 1;
}
int x = 5;
inc(&x);
…

!! cin >> x;
!! operator >> (cin, x);
!! who is the value of x changed by this function??

C++ has a different “pointer-like” type 

ref:

Lvaue Ref:
	int y = 10;
	int &z = y; // z is a lvalue reference to y. (& is part of the declaration.) 

A lvalue ref acts as a constant pointer with automatic dereferencing.

z will always points to y!! z is a constant ref to y!!

	z = 15; // updates y to 15 (automatic deref)
	int *p = &z // p points to y (automatic deref)
	int *&rp = p; (rp is a ref to a pointer)
	int &&z1 = z;

- z is a alias of y (other name)
- We cannot create a pointer to a ref.
- cannot leave reference uninitialized.
- Must initialize a reference to a lvalue.
- But we can create a ref to  a pointer.
- cannot create a ref to a ref
- cannot create a array of refs.
- the size of ref is uncertain!! (just a different name)

lvalue vs rvalue:
- lvalue refers to a storage location.
- anything that has a address.
- local vars are lvalues.

- rvalue refers to computed values
- eg. x + y

illegal : int &x = 5; 
		  int &z = x + y;

Ways of using refs:
- pass by ref
eg. 
	void inc(int &n) {
		n = n + 1;
	}
	int x = 5;
	inc(x);

Back to: 
	cin >> x;
	operator >> (cin, x);
!! This is passed by reference !!

eg.
	istream &operator >> (stream &in, int &n) {…}
!! why is the first argument passed by ref?
!! streams cannot be copied !!

!! why does operator>> return stream?
!! this allows chaining !!
!! returning by value would return a copy !!

Pass by value vs Pass by ref

	struct ReallyBig{…};
	void f(ReallyBig rb) {…};

	ReallyBig bd = …
	f(db); // expensive;

If we want to avoid the copy, we can use pointer or ref.

eg.
	void g(ReallyBig *rb) {…};
	g(&db);

	void h(ReallyBig &rb) {…};
	h(db);

	void g(const ReallyBig *rb) {…}; (or ReallyBig const *rb)
	g(&db);

Advice: Always pass by reference to a const unless there is a good reason not to.
- no copy so efficient
- use const to prevent change to the original value

Exceptions to the rule:
	void f(int &x) {…}
	void g(const int &x) {…}
illegal: f(5) f(x + y)
!! legal: g(5) g(x + y) !! (because we promised not to change the dereferenced value) !!

Always use ref!!

Dynamic/heap allocation:

	int *p = malloc(length *struct);
	free(p);

Do not use malloc in C++

	struct Node {
		int data;
		Node *next;
	}

we use: new and delete
	Node *np = new Node;(type aware)
	delete np;

	void f() {
		Node n;
		Node *np = new Node;
	}

!! np is in the stack !!

Heap allocated memory continues to live beyond the scope of the variable pointing to the memory !! (memory leak)

We get 0 on tests if we have memory leak!! 

To allocate memory of an array;

This is how we do it:
	Node *np = new Node[10];
	delete [10] np;

	Node *getMeANode(){
		Node n;
		return *n; // this a dangling pointer
	}


Operator:

<<, >>, + : different meanings.

In C++, we can give meaning to C++ operators for user defined types.

Eg1.

Struct Vec {
	int x, y;
};

Vec v1{1, 2};
Vec v2{3, 4};
Vec v3 = v1 + v2; // This will not work.
Vec v4 = 3 * v1; // This will not work.
Vec v5 = v1 * 3; // This will not work.

Vec operator+(const Vec &lhs, const Vec &rhs) {
	Vec v{lhs.x + rhs.x, lhs.y + rhs.y};
	return v;
}

Vec operator*(int k, const Vec &v) {
	return {k*v.x, k*v.y}; // This is valid cause the compiler is smart!!
}

Vec operator*(const Vec &v, int k) {
	return k*v;
}

Eg2.

struct Grade{
	int mark;
};

I want to : cout << g;

ostream &operator<<(ostream &out, const Grade &g) {
	out << “Your grade: ” << g.mark << “%”;
	return out;
}

I also want to : cin << g;

istream &operator>>(istream &in, Grade &g) {
	in >> g.mark;
	if (g.mark < 0) g.mark = 0;
	if (g.mark > 100) g.mark = 100;
	return in;
}

C/C++ preprocessor: 

- When you compile a program, the preprocessor runs before the compiler.
- #_______ :preprocessor directive
- #<____> look into the std library
- #”_____” look into the current directory
- g++14 -E -P file : this only run the 
- #define VAR VALUE
- The preprocessor will search for VAR and replace it with VALUE

Conditional Compilation:

- g++14 compiler has a -D command line option to give preprocessor directives.
- use #if #elif #endif to do conditional compile!
- Preprocessor code comment out nests nicely.
- #ifdef VAR
- #ifndef VAR

Eg.

$> g++14 -E -P -DVAR=VALUE <file>

Comment:

#if 0
	#if 0
	#endif
#endif

Separate Compilation:

Check out separate/example1

Interface: .h

Implementation: .cc

NEVER compile a header file!!

1. g++14 *.cc
2. g++14 main.cc vector.cc 
3. (I would like to separately compile individual cc files to produce portions of the executable and then merge all the portions.)(By default, g++14 tries to compile link and produce executables)

3. use $> g++ -c vector.cc // This will also produce .o files!! These are pieces of executables

- Then use $> g++14 vector.o main.o
- Link the pieces of the program
- produces executables

Global Variables:

- use the “extern” key words
- extern int global in .h;
- Never include a .cc file;
- Never compile a .h file;
- I don’t want to track includes manually;
- Never place “using namespace std;” in a header file;
- instead use std::string, std::cout, etc

abc.h

	extern int global;

abc.cc
	int global; // declare and definition: here definition is not initialization 

Classes:

- Big idea in object oriented programming: place functions in side a struct;
- A class is a struct that may contain functions;
- There is a “class” keyword;
- An instance of a class is called an object, a value of type student is a student object;
- A function inside class is called a “member function” or “method”;
- A method for class C can only be called using an object of class C;
- Inside the method, the method has access to the fields of the object on which this method was called;

EG.

struct Student {
	int assns, mt, final;
	float grade() {
		return 0.4 * assns + 0.2 * mt + 0.4 * final;
	}
}

Student billy {60, 70, 75};

cout << billy.grade() << endl;

Function vs Method:

- All methods have a hidden parameter named “this”;
- “this” is a pointer to the object on which this method was called;
- it is totally up to me whether to use “this”;

Eg.

struct Student {
	int assns, mt, final;
	float grade() {
		return this->assns * 0.4 + this->mt * 0.2 + this->final * 0.4;
	}
}

Student billy{60, 70, 80};

// This is a C-style initialization: value must be constants;
// C++ allows writing methods called constructors, which has 2 rules:
- the function name is same as the class;
- There is no return type;

struct Student {
	int assns, mt, final;
	float grade(){…};
	Student(int assns, int mt, int final) {
		this->assns = assns;
		this->mt = mt;
		this->final = final;
	}
}

	Student billy{60, 70, 80};

- if a 3 parameters constructor exists, that is called. 
- Otherwise use C-style initialization:

	Student billy = Student{60, 70, 80};
	Student billy = Student(60, 70 ,80);

1. int x = 5; string s = “h”;
2. int x(5); string s(“h”);
3. int x{5}; string s{“h”};

3 will always work!!


Heap allocation:

	Student *pBilly = new Student{60, 70, 80};

Advantages of constructors:

- full features of C++ available to function (if, for, while);
- Overloading;
- Default values;
- Sanity checks/ class invariants;

EG.

struct Student {
	int assns, mt, final;
	float grade(){…};
	Student(int assns = 0; int mt = 0; int fianl = 0) {
		this->assns = assns < 0 ? 0 : assns;
		this->mt = mt < 0 ? 0 : assns;
		this->final = final < 0 ? 0 : final;
	}
}

Then I could write :
	Student billy2{60,70};
	Student billy3{60};
	Student billy4{};
	Student billy5;

Default Constructor:

Every class comes with a default (0 parameter) constructors
- it calls the default constructors on any fields that are objects

struct A {
	int x;
	student y;
	Vec *v;
}

A myA; //calls the default constructor 
- y is default constructed
- note that x and v have not been initialized;

Vec v; // calls default constructor 
- v has 2 int therefore not initialized;

Rule: the default ctor goes away as soon as you implement any ctor.

struct Vec{
	int x, y;
	Vec(int x, int y) {
		this->x = x;
		this->y = y;
	}
};

Vec v; // will not compile;

!! Fields that are constants or references 
- must be initialized.

struct Mystruct {
	const int x = 5;
	int &z = y;
};

This will be useless as all objects will have the same value.

We want id to be a const for each Student Object. But each student gets a different id.

Rule: fields must already be constructed before the ctor body runs.

3 steps to object creation:
1. space is allocated;
2. fields are default constructed;
3. constructors body runs;

Lets hijack step 2 using:
MIL(member initialization list)
 EG>

struct Student{
	const int id;
	int assns, mt, final;
	Student(int id, int assns, int mt, int final) 
		: id{id}, assns{assns}, mt{mt}, final{final} {}
}

- MIL can be used to initialize all fields 
- In the MIL, for each pair the “thing” outside the braces {} must be a field.
- inside the braces, the scoping rules apply.
- MIL initializes fields in class declaration order.
- Using an MIL can be more efficient than using the constructor body.
- MIL replaces the default constructed.


struct Vec{
	int x = 5;
	int y = 10;
	Vec(int x, int y) : x{x}, y{y} {}
};

MIL has priority over in-class initialization;

Copy constructor:

Student billy{60, 70, 80};

Student boby = billy;
Student boby{billy};
- This called the copy constructor;
- A copy of the existing object is made;
- A copy constructor is default defined;

A class comes with 
1. default constructor;
2. copy constructor;
3. copy assignment operator;
4. destructor;
5. move constructor;
6. move assignment operator;

struct Student { 	…
	Student (const Student &other) : assns{others.assns}, mt{other.mt}, final{other.final} {}
};

Sometimes the default copy constructor is not what we want. 

struct Node {
	int data;
	Node *next;
	Node(int data, Node *next) 
		: data{data}, next{next} {}
	Node(const Node &other) 
		: data{other.data}, next{other.next} {}

Node *np = new Node{1, new Node{2, new Node{3, nullptr}}};

Node n = *np;
Node n{*np};
Node *m = new Node{*np};

If we don’t want nodes to be shared, we cannot use the copy constructors, and we must implement our own (deep copy) (when there is a class that has pointer to the heap);

EG.

struct Node{ 	…
	Node(const Node &other){
		data = other.data;
		if (other.next) {
			next = new Node{*other.next};
		}
		else {
			next = nullptr;
		}
	}
};

struct Node{ 	…
	Node(const Node &other) : 
		data{other.data},
		next{other.next ? new Node{*other.next} : nullptr} {}
};

Places where a copy constructor is called :
1. constructing an object as a copy of another;
2. pass by value;
3. return by value;

implicit conversions!!

Node n = 4; // This will work.
void foo(Node n ){…}
foo(4)

string str = “hello”
- string class has a 1 parameter constructor of type char *;

We can disable the automatic conversion by declaring explicit


explicit Node(int n, Node  )

TUT:

- We can use Valgrind to find undefined behaviours and memory errors;
- The distinction between struct and class is whether it has a function inside;
- Default constructor = constructor with no argument;
- compiler will provide a default constructor, but only provided if no user-defined constructor



TUT ends;

Destructor:

- When an object is destroyed , the destructor runs;
- stack allocated object are destroyed automatically when they go out of scope;
- heap allocated objects are destroyed when we call delete on a ptr to the object;

3 steps:

1. destructor body runs;
2. fields that are objects are destroyed(reverse of declaration order);
3. space is deallocated.

- A class has only one destructor;
- The destructor of a class is named: ~ClassName();
- A class comes with a default destructor;
- calls destructors on fields that are objects;

Eg.

Node *np = new Node{1, new Node{2, new Node{3, nullptr}}};

delete np;// This is destroying Node 1 with 2 and 3 still leaking;

struct Node {
	…
	~Node(){
		delete next; // THIS IS RECURSIVE!!! ????
	}
}

!! You don’t really have to delete any other thins!!!

Copy Assignment Operator:

Student billy{60, 70, 80};
Student bobby = billy; // copy constructor
Student jane;
jane = billy; // copy assignment operator;

struct Node {
	…
	Node &operator=(const Node &other) {
		this->data = other.data;
		delete this->next;
		this->next = other.next ? new Node(*other.next) : nullptr;
		return *this;
	}
}

Since the operator= updates an existing object, next might already be pointing to heap memory;

Node n{1, new Node{2, nullptr}};

n = n; // this is leaking memory;

struct Node {
	…
	Node &operator=(const Node &other) {
		if (this == &other) return *this;
		this->data = other.data;
		delete this->next;
		this->next = other.next ? new Node(*other.next) : nullptr;
		return *this;
	}
}

struct Node {
	…
	Node &operator=(const Node &other) {
		if (this == &other) return *this;
		Node *tmp = this->next;
		this->next = other.next ? new Node(*other.next) : nullptr;
		delete tmp;
		this->data = other.data;
		return *this;
	}
}

Implementing operator= using copy of swap;

#include <utility>

struct Node {
	…
	void swap(Node &other){
		using std::swap;
		swap(data, other.data);
		swap(next, other.next);
	}
	Node &operator=(const Node &other) {
		Node tmp = other;
	}
}

!! PASS BY VALUE IS USING THE COPY CONSTRUCTOR

EG.

Node plusOne(Node n){
	n.value += 1;
	return n;
}
Node n{1, new Node{2, nullptr}};
Node n2{plusOne(n)};

This call the copy constructor 6 times!!

To avoid copy something that is about to be destroyed, we write a move constructor.

We want a way to be able to refer to temporary objects(something that is about to be destroyed).

C++ has rvalue references (&&):
- references to temporary objects.
we can write a constructor which takes a Node && (Node rvalue referance) as a parameter.

- Move constructor

struct Node {
	…
	Node (Node &&other): data{other.data}, next{other.next} {
		other.next = nullptr;
	}
}

If we have this, we will call copy constructor 4 times and move constructor 1 times.

Move assignment operator:

struct Node{
	…
	Node &operator=(Node &&other) {
		swap(other);
		return *this;
	}
}

You get a move constructor and move assignment operator for free:
- Theses go away as soon as you implement any copy constructor, copy assignment oeprator, destructor, move assignment operator, move constructor.
- If a move version of copy constructor and copy assignment operator is available, it is called when the RHS is a rvalue.

Copy/Move Elision:
node.cc — 4 * copy constructor;
nodemove.cc — 2 copy constructor + 1 mock constructor;



Vec makeAVec() { return {2, 3}; };

Vec v=makeAVec();

We would expect either a copy constructor or a move constructor to be called. But in fact the vec V is directly constructed with values {2, 3}.
Compilers are allowed to omit 

This is a good optimization but the compiler also avoid the side effects

EGs in c++/elision/vec.cc

To turn off optimization:
use:
g++14 -fno-elide-constructor (files).

Rule of 5:
If you need to implement a custom version of any of:
1. copy constructor;
2. copy assignment operator;
3. destructor;
4. move constructor;
5. move assignment operator;
!!! typically you need to implement all of them!!!

Methods vs Standalone functions:
- Operator overloading;
- operator= must be implemented as a method;
- LHS was represented by the “this” ptr;

Implementing + and * for Vec as methods

struct Vec {
	int x,y;
	Vec operator+(const Vec &v) {
		return { x + v.x, y + v.y};
	}
	Vec operator*(const int k) { 		return { x*k , y*k};
}

this only works with v1+v2, v*5;

to use 5*v
we have to use a function;

Implementing I/O operator does not go with intuition:
 x << (v << cout);

We are required to use methods :
- operator=
- operator[]
- operator()
- operator->
- operatorT() // this means type;

Arrays of Objects:
struct Vec {
	int x,y;
	Vec(int x, int y): x{x}, y{y} {}
}

Vec v1[3]; // this won’t compile
Vec *v2 = new Vec[3]; // this won’t compile
Default constructor wen away as soon as we implemented our own constructor;

FIX:
1. provide default constructor;
2. stack allocated arrays of objects -> can use array initialization: 
Vec vec1[3] = {vec{0,0}, vec{1,2}, vec{3,4}};
3. stack/heep
- create array of pointers instead of objects;
- Stack: Vec *vec3[10]; alloc
- 
- exiate array of Vec pointers;
- Heap: Vec **vecs4 = new Vec*[10];
                vecs4[0] = new Vec{2, 3};
				heap allocated array containing heap allocated Vecs
- to destroy:  


Separate Compilation:
Method headers go i the header file.
Method implementation goes in the cc file.

node.h
#ifndef NODE_H
#define NODE_H
struct Node {
	int data;
	Node *next;
	Node(int data, Node *next){}



Const Method:

Struct Student  {
	int assns, mt, final;
	float grade() const// does not compile without this!
		{ return asana* 0.4 + mt*0.2 + final*0.4; }
}

const student billy {60, 70, 80};
cout << billy.grade() << endl; // doesn’t compile without const????
- because grade did not promise that it won’t change the field. 

A const method does not modify the fields of the object on which the method was called.
- the compiler will check for this;

We can only call method that are const on const objects!!

struct Student {
	mutable int counter = 0;
	float grade() const {
		++counter;
		return…;
	}
}

Static fields & member functions:
- static fields/functions are associated with the class and not any object of the class.
- We do not need an object to access a static field as call a static member function.
- static member functions do not have the “this“ pointer
- static member functions can only access static fields and call other static member function.

struct Student {
	static int numObjects; // declaration!!
	Student() {
		…
		++numObjects;
	}
	static int getCount() { return numObject;}
}

C++ Rule: static fields must be defined in an external file!!

student.cc
int Student::numObjects = 0;

int main() {
	Student s1{}, s2{};
	cout << Student::numObject << endl;
	cout << Student::getCount() << endl;
}

Invariants & Encapsulation:

struct Node{
	int data;
	Node * next;
	Node(int data, Node *next)…
	~Node(){delete next;}
}

int main() {
	Node n1{1, new Node{2, nullptr}};
	Node n3{3, nullptr}; // deleting nullptr is fine.
	Node n4{4, &n3}; // crashes because &n3 is in the stack.
}

When the main finishes, the destructors are called.

Invariant: an assumption/statement that is supposed to be hold true, for the class to function correctly.

Node class invariant:
- next is either a nullptr or points to the heap;

It is impossible to prevent clients from breaking the invariant as long as they have access to the class implementation!

Stack invariant :
- LIFO
- if a client has access to the array containing stack contents the invariant cannot be guaranteed!

Encapsulation: Treat the object in the class as a black boxes(a capsule).
- Hide the implementation;
- Allow clients access through a provided interface;

Keywords: private/public
private: what programmers have to know;
public: what normal people wants to know;

struct Vec {
	// default visibility is public
	Vec(int x, int y): x{x}, y{y} {}
	private: // anything that follows is private from outside!
		int x;
		int y;
	public: // change visibility to public
		Vec operator+(…)
};

int main() {
	Vec v{3, 4}; //2 param constructor is public, since structs have public visibility by default;
	Vec v1 = v + v;
	int num = v.x + v.y; // this cannot happen!!
}

Advice: at a minimum all fields should be private!!

We have another keywords “class” which is identical to struct but the default visibility is private!

EG.

class Vec {
	int x;
	int y;

public:
	Vec(…)…
	Vec operator+(…)…
};

All helper method should be private!!
A helper method helps in functionality!!

Guaranteeing the Node invariant:
-> Create a List wrapper class

list.h

class List {
	struct Node; // declaring a private, nested class
	Node *thelist;
	public:
	void addToFront(int n);
	int ith(int i);
	~List();
};

list.cc

struct List::Node {
	int data;
	Node *next;
	Node(int data, Node *next): data{data}, next{next}{};
	~Node(){delete next;}
};

List::~List(){ delete theList;};

void List::addToFront

!! To get the i th element, Tn = O(n^2) !!

Create an O(n) traversal for the list.

Iterator Design Pattern:

- create a class(Iterator) that manages access to Nodes.
- the class will act as an abstraction of a pointer into the linked list.

Inspiration:
// arr is an int array
for (int *p=arr; p != arr + array.size; ++p) {
	…*p…
}

TODO list:

Iterator class should support
- operator *
- operator ++
- operator != (==)
- begin()
- end()

class List {
	struct Node;
	Node * theList = nullptr;
	public:
	class Iterator {
		Node *curr;
		public:
		explicit Iterator(Node * curr): curr{curr} {}

		int& operator*() cosnt{
			return curr->data; // return by reference gives clients access to “data”
		}
		
		Iterator &operator++() {// this is the syntax for prefix!!use as ++p
			curr = curr->next;
			return *this;
		}

		bool operator==(const Iterator &other) {
			return (curr == other.curr);
		}

		bool operator!=(const Iterator &other) {
			return !(*this == other);
		}
	}; // end Iterator

	Iterator begin() {
		return Iterator{theList};
	}

	Iterator end() {
		return Iterator{nullptr};
	}
……
}

CLIENT CODE:

int main() {
	List lst;
	lst.addToFront(1);
	lst.addToFront(2);
	lst.addToFront(3);
	for (List::Iterator it = lst.begin(); it != lst.end(); ++it) {
		cout << *it << endl;
	}
}

“auto Keyword: automatic type deduction”

auto x = y; // define a x as the same type as y;
List::Iterator can be replaced by auto;

We can use C++’s built in support for he Iterator Design Pattern:
	Range-based for loops—
for (auto n : lst) {
	cout << n << end;
}
!!n is a copy!!
The type of n is int : *it!!!

A range-based for loop requires:
1. class C implements begin() and end() which return iterator objects;
2. the iterator class implements *, !=, ++

Encapsulation (contd):
	constructor for Iterator is public, which is bad!
We want to make constructor in Iterator private.
But List::begin and List::end use the constructor!!

Friend:

Iterator can declare List as a friend!!!

class Iterator {
	Node *curr;
	explicit Iterator …//constructor;
	……
	friend class List; // give List all the access to the private area!!
}

MAKE AS FEW FRIENDS AS POSSIBLE!!

Advice: make fields private!!
Provide accesses/mutators!!

Suppose:
- Vec::x and Vec::y are private:
- not get(x) or anything

To implement an operator<<
!! We can make operator << a friend !!

System Modeling:

UML: Unified Modelling language 

【在这里插入图片】

class Vec{
	int x,y;
	public:
	Vec(int x, int y): x{x}, y{y} {}
};


class Basis{
	Vec v1, v2;
};

Basis b won’t compile!!

Fix:
1. provide default actor for Vec;
2. Use the MIL to call an alternate ctor;

Basis::Basis(): v1{0, 1}, v2{2, 3} {}

Composition(OWNS A): embedding an object inside another;

Basis “owns a” Vec!!

Typically class “A” owns a class “B” if :
- B has no existence of its own;
- if A is copied, B is copied(deep copy);
- if A is destroyed, B is destroyed

在这里插入图片

Aggregation(HAS A): 

Typically a class “A” has a class “B” 
- B can exist on its own;
- if we copy A, we don’t don’t copy B;
- if we destroy A, we don’t destroy B;

在这里插入图片

implement using pointers.

Inheritance(IS A): 

class Book {
	-tile
	-author
	-numPages
}

class Text {
	-tile
	-author
	-numPages
	-topic
}

class Comic {
	-tile
	-author
	-numPages
	-hero
}

!! A text is a Book with an extra topic field !!
!! A Comic is a Book with an extra hero field !! 

在这里插入图片

Base class, parent class, superclass
Derived class, child class, subclass

A child class inherits members(fields, methods) from it s parents.
!! Any method that you can call on a Book object, you can call on a Text/Comic !!

Inheriting Private Members:

subclasses inherit private fields/methods as well.
Text has inherited title, author, numPages

!!!Rule: Since title, author, numPages in private in Book, it is not accessible in Text!!!!

Text t = …
t.author// Won’t compile

EG.

class Book {
	string title, author;
	int numPages;
	public: 
	Book(string title, string author, int numPages) :
		title{title}, author{author}, numPages{numPages} {}
};

class Text : public Book{ // won’t compile
	string topic;
	public:
	Text(string title, string author……):
		title……
	{}
}

Why the Text for does not compile?? 
1. title, author, numPages are private in Book
2. even if these inherited fields were public, still won’t compile — Rule: the MIL for Text can only use fields it declared
3. Steps for object construction —
 	1. space is allocated;
	2. superclass past of the object is constructed;
	3. field initialization for fields declared in the class;
	4. ctor body;

- The Text ctor won’t compile, because in step 2 of object construction the Book part is default cosntructed

How to fix?
1. provide default Book ctor;
2. call a non-default actor in the MIL;

Text::Text(string title, string author, int numPages, string topic) :
	Book{title, author, numPages},
	topic{topic} {}

Protected visibility

class Book {
	protected:
	string title, author;
	int numPages;
	public:
	……
}

Protected members are accessible by the class but also the subclasses.
The Text class could implement:
void Text::addAuthor(string auth) {
	author += auth;
}
Now I can access author in Text!!

!! Protected breaks encapsulation !!

ADVICE: Keep fields private, if needed give protected accessors or mutators

Method Overriding Dynamic Dispatch

Book: isHeavy: numPages > 300;
Text: isHeavy: numPages >500;
Comic: isHeavy: numPages > 30;

class Book {
	int numPages;
	public;
	int getNumPages() const {
		return numPages;
	}
	bool isHeavy() const {
		return numPages > 200;
	}
};

class Comic: public Book {
	……
	public: 
	bool isHeavy() const {
		return getNumPages() > 30;
	}
};

Book b{…};
Comic c{…};
b.isHeavy(); // Book::isHeavy
c.isHeavy(); // Comic::isHeavy

Book b2 = Comic(…, …, 40, …);

b2.isHeavy(); // Book::isHeavy!!!

When a subclass object is placed into a superclass variable, the subclass object is SLICED. — object coercion 

Pointers to subclass Objects:

Comic c{…, …, 40, …};

Comic *cp{&c};
cp->isHeavy(); // Comic::isHeavy;
Book *bp{&c};
bp->isHeavy(); // Book::isHeavy;

RULE: compiler looks at the declared type of a pointer to choose which method will execute. (static dispatch)
— decision is made at compile time.

This is not what we want typically!! We want to use a book pointer to point at all the objects that can be classified as a book!!

KEYWORD: virtual

class Book {
	…
	public:
	virtual bool isHeavy() const {…}
};

class Comic : public Book {
	public:
	bool isHeavy() const override {…}
};

Comic c{…, …, 40, …};

Comic *cp{&c};
Book *bp{&c};
Book &rb{c};

cp->isHeavy; // comic
bp->isHeavy; // comic
rb.isHeavy; // comic

virtual: For virtual method, the decision of which method to call is delayed till the program is running
During execution, the runtime type of the object is used to choose the method.

Book *collection[20]; 

for (int i = 0; i < 20; i++) {
	collection[i]->isHeavy;
}

collection — Polymorphic array

polymorphism: ability to accommodate multiple types under one abstraction;

ostream &operator<<(ostream &out; Class &c) {
	……
}
We can send ostream(cout) as a variable of ofstream IS A stream, ostringstream IS A ostream.

Destructor Revisited:

inheritance/examples
class X {
	int *x;
	public:
	X(int n): x{new int[n]} {}
	~X() {delete [] x}
};

class Y : public X{
	int *y;
	public:
	Y(int n, int m) : X{n}, y {new int[m]} {}
	~Y() {delete [] y;}
};

~Y() should not worry about fields inherited from X;

RULE: when a subclass object is destroyed, the superclass door is automatically called.

X *myx = new Y{10, 20};
delete mix; // memory leak!!

solution: virtual

Advice: If a class may have subclasses, make the dtor virtual.
- even if the base class does not need to do anything in the dtor;

If a class does not allow subclasses to be created, use the “final” keyword :
class B final : public A {
	……
};

class Student {
	……
	public:
	virtual int fees() = 0; // P.V. method
};

class Coop: public Student {
	……
	public:
	int fees() override {…}
};

class Regular : public Student {
	public:
	int  fees() override {…}
};

We want Student::fees to not have an implementation:
	!! PURE VIRTUAL FUNCTION !!

VIRTUAL:
- classes may override behaviour
PURE VIRTUAL:
- subclasses must define behaviour

Student does not have a complete implementation
- c++ will not allow creation of instances/objects of an incomplete class

!! A class with at least one P.V. method is an abstract class
- A subclass of an abstract class is also abstract, unless it implements all P.V. methods
- A class with no P.V. methods is called “concrete”

Use abstract classes to 
- organize subclasses
- common place to put common fields and methods
- Polymorphism

Virtual P.V. name in italics
Abstract italics
static underline

